CREATE GRAPH

import com.sun.xml.internal.fastinfoset.util.StringArray;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.Stack;

class SLLNode<E> {
    protected E element;
    protected SLLNode<E> succ;

    public SLLNode(E elem, SLLNode<E> succ) {
        this.element = elem;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}
class LinkedQueue<E> implements Queue<E> {

    // Redicata e pretstavena na sledniot nacin:
    // length go sodrzi brojot na elementi.
    // Elementite se zachuvuvaat vo jazli dod SLL
    // front i rear se linkovi do prviot i posledniot jazel soodvetno.
    SLLNode<E> front, rear;
    int length;

    // Konstruktor ...

    public LinkedQueue () {
        clear();
    }

    public boolean isEmpty () {
        // Vrakja true ako i samo ako redicata e prazena.
        return (length == 0);
    }

    public int size () {
        // Ja vrakja dolzinata na redicata.
        return length;
    }

    public E peek () {
        // Go vrakja elementot na vrvot t.e. pocetokot od redicata.
        if (front == null)
            throw new NoSuchElementException();
        return front.element;
    }

    public void clear () {
        // Ja prazni redicata.
        front = rear = null;
        length = 0;
    }

    public void enqueue (E x) {
        // Go dodava x na kraj od redicata.
        SLLNode<E> latest = new SLLNode<E>(x, null);
        if (rear != null) {
            rear.succ = latest;
            rear = latest;
        } else
            front = rear = latest;
        length++;
    }

    public E dequeue () {
        // Go otstranuva i vrakja pochetniot element na redicata.
        if (front != null) {
            E frontmost = front.element;
            front = front.succ;
            if (front == null)  rear = null;
            length--;
            return frontmost;
        } else
            throw new NoSuchElementException();
    }

}
interface Queue<E> {

    // Elementi na redicata se objekti od proizvolen tip.

    // Metodi za pristap:

    public boolean isEmpty ();
    // Vrakja true ako i samo ako redicata e prazena.

    public int size ();
    // Ja vrakja dolzinata na redicata.

    public E peek ();
    // Go vrakja elementot na vrvot t.e. pocetokot od redicata.

    // Metodi za transformacija:

    public void clear ();
    // Ja prazni redicata.

    public void enqueue (E x);
    // Go dodava x na kraj od redicata.

    public E dequeue ();
    // Go otstranuva i vrakja pochetniot element na redicata.

}
class Graph<E> {

    int num_nodes; // broj na jazli
    E nodes[];    // informacija vo jazlite - moze i ne mora?
    int adjMat[][];  // matrica na sosednost

    @SuppressWarnings("unchecked")
    public Graph(int num_nodes) {
        this.num_nodes = num_nodes;
        nodes = (E[]) new Object[num_nodes];
        adjMat = new int[num_nodes][num_nodes];

        for(int i=0;i<this.num_nodes;i++)
            for(int j=0;j<this.num_nodes;j++)
                adjMat[i][j]=0;
    }



    public Graph(int num_nodes, E[] nodes) {
        this.num_nodes = num_nodes;
        this.nodes = nodes;
        adjMat = new int[num_nodes][num_nodes];

        for(int i=0;i<this.num_nodes;i++)
            for(int j=0;j<this.num_nodes;j++)
                adjMat[i][j]=0;
    }



    int adjacent(int x,int y)
    {  // proveruva dali ima vrska od jazelot so indeks x do jazelot so indeks y
        return (adjMat[x][y]!=0)?1:0;
    }

    void addEdge(int x,int y)
    {  // dodava vrska megu jazlite so indeksi x i y
        adjMat[x][y]=1;
        adjMat[y][x]=1;
    }

    void deleteEdge(int x,int y)
    {
        // ja brise vrskata megu jazlite so indeksi x i y
        adjMat[x][y]=0;
        adjMat[y][x]=0;
    }

    // Moze i ne mora?
    E get_node_value(int x)
    {  // ja vraka informacijata vo jazelot so indeks x
        return nodes[x];
    }

    // Moze i ne mora?
    void set_node_value(int x, E a)
    {  // ja postavuva informacijata vo jazelot so indeks na a
        nodes[x]=a;
    }

    public int getNum_nodes() {
        return num_nodes;
    }

    public void setNum_nodes(int num_nodes) {
        this.num_nodes = num_nodes;
    }

    void dfsSearch(int node) {
        boolean visited[] = new boolean[num_nodes];
        for (int i = 0; i < num_nodes; i++)
            visited[i] = false;
        dfsRecursive(node, visited);
    }

    void dfsRecursive(int node, boolean visited[]) {
        visited[node] = true;
        System.out.println(node + ": " + nodes[node]);

        for (int i = 0; i < this.num_nodes; i++) {
            if(adjacent(node, i)==1){
                if (!visited[i])
                    dfsRecursive(i, visited);
            }
        }
    }

    void dfsNonrecursive(int node) {
        boolean visited[] = new boolean[num_nodes];
        for (int i = 0; i < num_nodes; i++)
            visited[i] = false;
        visited[node] = true;
        System.out.println(node + ": " + nodes[node]);
        Stack<Integer> s = new Stack<Integer>();
        s.push(node);

        int pom;

        while (!s.isEmpty()) {
            pom = s.peek();
            int pom1 = pom;
            for (int i = 0; i < num_nodes; i++) {
                if(adjacent(pom,i)==1){
                    pom1 = i;
                    if(!visited[i])
                        break;
                }
            }
            if(!visited[pom1]){
                visited[pom1] = true;
                System.out.println(pom1 + ": " + nodes[pom1]);
                s.push(pom1);
            }
            else
                s.pop();
        }

    }

    void bfs(int node){
        boolean visited[] = new boolean[num_nodes];
        for (int i = 0; i < num_nodes; i++)
            visited[i] = false;
        visited[node] = true;
        System.out.println(node+": " + nodes[node]);
        Queue<Integer> q = new LinkedQueue<Integer>();
        q.enqueue(node);

        int pom;

        while(!q.isEmpty()){
            pom = q.dequeue();
            for (int i = 0; i < num_nodes; i++) {
                if(adjacent(pom, i)==1){
                    if (!visited[i]){
                        visited[i] = true;
                        System.out.println(i+": " + nodes[i]);
                        q.enqueue(i);
                    }

                }
            }


        }

    }

    @Override
    public String toString() {
        String ret="  ";
        for(int i=0;i<num_nodes;i++)
            ret+=nodes[i]+" ";
        ret+="\n";
        for(int i=0;i<num_nodes;i++){
            ret+=nodes[i]+" ";
            for(int j=0;j<num_nodes;j++)
                ret+=adjMat[i][j]+" ";
            ret+="\n";
        }
        return ret;
    }
    public void printMatrix()
    {
        for(int i=0;i<adjMat.length;i++)
        {
            for(int j=0;j<adjMat[0].length;j++)
            {
                System.out.print(adjMat[i][j]+" ");
            }
            System.out.println();
        }
    }
    public void printNode(E temp)
    {

        for(int i=0;i<num_nodes;i++)
        {
            for(int j=0;j<num_nodes;j++)
            {
                if(temp.equals(adjMat[i][j]))
                {
                    System.out.println(temp);
                    break;
                }
            }
        }

    }


}
public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        String [] array = br.readLine().split(" ");
       // Arrays.stream(array).forEach(System.out::println);
        Graph<Integer> graph = new Graph<>(Integer.parseInt(array[1]));
        System.out.println(graph.toString());
        for(int i = 0 ; i < N ;i++)
        {
            int node1 = -1;
            int node2 = -1;
            String[] parts= br.readLine().split(" ");
            String command = parts[0];
            if(parts.length==2)
                node1 = Integer.parseInt(parts[1]);
            if(parts.length==3)
            {
                node1 = Integer.parseInt(parts[1]);
                node2 = Integer.parseInt(parts[2]);
            }
            if (command.equals("ADDEDGE")){
                graph.addEdge(node1,node2);
            }
            else if (command.equals("PRINTMATRIX")){
                for(int j = 0 ;j < graph.num_nodes;j++) {
                    for (int k = 0; k < graph.num_nodes; k++) {
                        System.out.print(graph.adjMat[j][k] + " ");

                    }
                    System.out.println();
                }
            }
            else if(command.equals("PRINTNODE"))
            {
                int num = node1 + 65;
                char c = (char) num;
                System.out.println(c);
            }
            else if(command.equals("ADJACENT"))
            {
                System.out.println(graph.adjacent(node1,node2));
            }
            else if(command.equals("DELETEEDGE"))
            {
                graph.deleteEdge(node1,node2);
            }
        }

        }
    }



RANGE

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Range {

    static long proveri(long N, long A, long B) {
        // Vasiot kod tuka
        if(A == B) return -1;

        if(calculate(A) == N) return A;
        else if(calculate(B) == N) return B;

        long middle = (A+B)/2, temp;
        temp = calculate(middle);

        if(temp > N) return proveri(N, A, middle);
        else if(temp < N) return proveri(N, middle, B);
        else return middle;
    }

    static long calculate(long x)
    {
        return (long) ((x*x) + sumOfDigits(x) + (200*x));
    }

    public static long sumOfDigits(long n)
    {
        return n == 0 ? 0 : n % 10 + sumOfDigits(n/10);
    }

    public static void main(String[] args) throws Exception {
        int i,j,k;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        long N = Long.parseLong(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        long A = Long.parseLong(st.nextToken());
        long B = Long.parseLong(st.nextToken());

        long res = proveri(N, A, B);
        System.out.println(res);

        br.close();

    }

}


SUM OF ELEMENTS(WITH DEQUES)


package com.company;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.StringTokenizer;

class BNode<E> {

    public E info;
    public BNode<E> left;
    public BNode<E> right;

    static int LEFT = 1;
    static int RIGHT = 2;

    public BNode(E info) {
        this.info = info;
        left = null;
        right = null;
    }

    public BNode() {
        this.info = null;
        left = null;
        right = null;
    }

    public BNode(E info, BNode<E> left, BNode<E> right) {
        this.info = info;
        this.left = left;
        this.right = right;
    }

}

class BTree<E extends Comparable<E>> {

    public BNode<E> root;

    public BTree() {
        root = null;
    }

    public BTree(E info) {
        root = new BNode<E>(info);
    }

    public void makeRoot(BNode<E> elem) {
        root = elem;
    }
    public void preorder() {
        System.out.print("PREORDER: ");
        preorderR(root);
        System.out.println();
    }

    public void preorderR(BNode<E> n) {
        if (n != null) {
            System.out.print(n.info.toString()+" ");
            preorderR(n.left);
            preorderR(n.right);
        }
    }

    public void makeRootNode(BNode<E> node) {
        root = node;
    }

    public BNode<E> addChild(BNode<E> node, int where, BNode<E> tmp) {

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }
        return tmp;

    }

    public BNode<E> addChildNode(BNode<E> node, int where, BNode<E> tmp) {

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }

        return tmp;
    }

}

public class BinaryTreeSum {

    public static int preorderAdd(BNode<Integer> n, int M){
        int sum = n.info;
        if (n != null && (sum < M)) {
            return (sum + preorderAdd(n.left, M) + preorderAdd(n.right, M));
        }
        else {
            return 0;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        BNode<Integer> [] list = new BNode[N];

        for (int i = 0; i < N; i ++){
            list[i] = new BNode<>();
        }

        BTree<Integer> tree = new BTree<>();
        for (int i = 0; i < N; i ++){
            String [] s = br.readLine().split(" ");
            int index = Integer.parseInt(s[0]);
            int data = Integer.parseInt(s[1]);
            list[index].info = data;
            int parent = -1;
            String where = s[2];
            if (s.length == 4){
                parent = Integer.parseInt(s[3]);
            }
            if (where.equals("LEFT")){
                tree.addChild(list[parent],BNode.LEFT,list[index]);
            }
            else if (where.equals("RIGHT")){
                tree.addChild(list[parent],BNode.RIGHT,list[index]);
            }
            else {
                tree.makeRoot(list[index]);
            }

        }
      //  System.out.println();
        int M = Integer.parseInt(br.readLine());
       // tree.preorder();
       // System.out.println();
        System.out.println(M);
        printSum1Sum2(tree,M);





    }
    public static void printSum1Sum2(BTree<Integer> tree,int val)
    {
        BNode<Integer> temp1 = tree.root;
        Deque<BNode<Integer>> dq1 = new ArrayDeque<>();
        Deque<BNode<Integer>> dq2 = new ArrayDeque<>();
        dq1.push(temp1.left);
        dq2.push(temp1.right);
        int sum1 = 0;
        int sum2 = 0;
        while(!dq1.isEmpty())
        {
            BNode<Integer> temp = dq1.pop();
            System.out.println(temp.info);
            if(temp.info<val)
            {
                sum1+=temp.info;
            }
            if(temp.right!=null)
              dq1.push(temp.right);

            if(temp.left!=null)
              dq1.push(temp.left);
        }
        while(!dq2.isEmpty())
        {
            BNode<Integer> temp = dq2.pop();
            if(temp.info>val)
            {
                sum2+=temp.info;
            }
            if(temp.right!=null)
                dq2.push(temp.right);

            if(temp.left!=null)
                dq2.push(temp.left);
        }
        System.out.println(sum1 + " " + sum2);

    }
}



SOLDIER--
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

class DLLNode<E> {
    protected E element;
    protected DLLNode<E> pred, succ;
    protected int index;

    public DLLNode(E elem, DLLNode<E> pred, DLLNode<E> succ) {
        this.element = elem;
        this.pred = pred;
        this.succ = succ;
        index=0;
    }

    @Override
    public String toString() {
        return "<-" + element.toString() + "->";
    }
}

class DLL<E> {
    private DLLNode<E> first, last;

    public DLL() {
        // Construct an empty SLL
        this.first = null;
        this.last = null;
    }

    public void deleteList() {
        first = null;
        last = null;
    }

    public int length() {
        int ret;
        if (first != null) {
            DLLNode<E> tmp = first;
            ret = 1;
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret++;
            }
            return ret;
        } else
            return 0;

    }

    public void insertFirst(E o) {
        DLLNode<E> ins = new DLLNode<E>(o, null, first);
        if (first == null)
            last = ins;
        else
            first.pred = ins;
        first = ins;
    }

    public void insertLast(E o) {
        if (first == null)
        {
            insertFirst(o);

        }

        else {
            DLLNode<E> ins = new DLLNode<E>(o, last, null);
            last.succ = ins;
            last = ins;
        }
    }

    public void insertAfter(E o, DLLNode<E> after) {
        if (after == last) {
            insertLast(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, after, after.succ);
        after.succ.pred = ins;
        after.succ = ins;
    }

    public void insertBefore(E o, DLLNode<E> before) {
        if (before == first) {
            insertFirst(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, before.pred, before);
        before.pred.succ = ins;
        before.pred = ins;
    }

    public E deleteFirst() {
        if (first != null) {
            DLLNode<E> tmp = first;
            first = first.succ;
            if (first != null) first.pred = null;
            if (first == null)
                last = null;
            return tmp.element;
        } else
            return null;
    }

    public E deleteLast() {
        if (first != null) {
            if (first.succ == null)
                return deleteFirst();
            else {
                DLLNode<E> tmp = last;
                last = last.pred;
                last.succ = null;
                return tmp.element;
            }
        }
        // else throw Exception
        return null;
    }

    @Override
    public String toString() {
        String ret = new String();
        if (first != null) {
            DLLNode<E> tmp = first;
            ret += tmp + "<->";
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret += tmp + "<->";
            }
        } else
            ret = "Prazna lista!!!";
        return ret;
    }

    public DLLNode<E> getFirst() {
        return first;
    }

    public DLLNode<E> getLast() {

        return last;
    }

}



public class Main {

    public static void main(String[] args) throws IOException {
        DLL<Integer> lista = new DLL<Integer>();
        BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
        String s = stdin.readLine();
        int N = Integer.parseInt(s);
        s = stdin.readLine();
        String[] ids = s.split(" ");
        for (int i = 0; i < N; i++) {
            lista.insertLast(Integer.parseInt(ids[i]));
        }

        s = stdin.readLine();
        String interval[] = s.split(" ");
        int a = Integer.parseInt(interval[0]);
        int b = Integer.parseInt(interval[1]);

        s = stdin.readLine();
        interval = s.split(" ");
        int c = Integer.parseInt(interval[0]);
        int d = Integer.parseInt(interval[1]);

        DLL<Integer> new_list = new DLL<>();
        DLLNode<Integer> head = lista.getFirst();
        int i = 1;
        DLLNode<Integer>first=null;
        DLLNode<Integer>second=null;
        DLLNode<Integer>third=null;
        DLLNode<Integer>fourth=null;
        while(head!=null)
        {
            if(head.element.equals(a))
            {
                first=head;
            }
            if(head.element.equals(b))
            {
                second=head;
            }
            if(head.element.equals(c))
            {
                third=head;
            }
            if(head.element.equals(d))
            {
                fourth=head;
            }

            head=head.succ;
        }

        DLL<Integer> list1 = new DLL<>();
        head = lista.getFirst();


            while (head != first) {
                list1.insertLast(head.element);
                head = head.succ;
            }




        DLL<Integer> list2  = new DLL<>();
        if(head==second)
        {
            //System.out.println(head.element);
            list2.insertLast(head.element);
            head=head.succ;
        }
        else {
            while (head != second) {
                list2.insertLast(head.element);
                head = head.succ;
            }
            list2.insertLast(head.element);
            head=head.succ;
        }

        DLL<Integer> list3  = new DLL<>();


            while (head != third) {
                list3.insertLast(head.element);
                head = head.succ;
            }



        DLL<Integer> list4  = new DLL<>();
        if(head==fourth)
        {
            list4.insertLast(head.element);
            head=head.succ;
        }
        else {
            while (head != fourth) {
                list4.insertLast(head.element);
                head = head.succ;
            }
            list4.insertLast(head.element);
            head=head.succ;
        }


        DLL<Integer> list5  = new DLL<>();

        while(head != null)
        {
            list5.insertLast(head.element);
            head=head.succ;
        }

        //--------------------------------------------------------------------//
        DLL<Integer>list6 = new DLL<>();

        head = list1.getFirst();
        if(list1!=null)
        {
            while (head!=null)
            {
                list6.insertLast(head.element);
                head=head.succ;
            }
        }

        head = list4.getFirst();
        if(list4!=null)
        {
            while (head!=null)
            {
                list6.insertLast(head.element);
                head=head.succ;
            }
        }

        head = list3.getFirst();
        if(list3!=null)
        {
            while (head!=null)
            {
                list6.insertLast(head.element);
                head=head.succ;
            }
        }


        head = list2.getFirst();
        if(list2!=null)
        {
            while (head!=null)
            {
                list6.insertLast(head.element);
                head=head.succ;
            }
        }






        head = list5.getFirst();
        if(list5!=null)
        {
            while (head!=null)
            {
                list6.insertLast(head.element);
                head=head.succ;
            }
        }

        head = list6.getFirst();
        while(head!=null)
        {
            System.out.print(head.element+" ");
            head=head.succ;
        }



    }
}

==========================================================================================================
SUMA OD ABSOLUTNI RAZLIKI
import java.util.*;
import java.math.*;

public class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int length = scan.nextInt();
        int size = scan.nextInt();

        ArrayList<Integer> arr = new ArrayList<>();

        for (int i = 0; i<length; i++){
            arr.add(scan.nextInt());
        }

        ArrayList<Integer> arr2 = new ArrayList<>();

        for (int i = 0; i<size; i++){
            if(i%2 == 0){
                arr2.add(getMax(arr));
            }
            else {
                arr2.add(getMin(arr));
            }

        }
        int counter = 0;
        for (int i = size-1; i>1; i--){
            counter = counter + Math.abs(arr2.get(i) + arr2.get(i-1));
        }
        System.out.println(counter);
    }

    public static int getMax(ArrayList<Integer> arr){
        int max = Integer.MIN_VALUE;
        for (int i : arr) {
            if (max < i)
            {
                max = i;
            }
        }
        return max;

    }

    public static int getMin(ArrayList<Integer> arr){
        int min = Integer.MAX_VALUE;
        for (int i : arr) {
            if (min > i)
            {
                min = i;
            }
        }
        return min;

    }
}
==========================================================================================================
(No idea which one this is)
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.NoSuchElementException;

class SLLNode<E> {
    protected E element;
    protected SLLNode<E> succ;

    public SLLNode(E elem, SLLNode<E> succ) {
        this.element = elem;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}
class SLL<E> {
    private SLLNode<E> first;

    public SLL() {
        // Construct an empty SLL
        this.first = null;
    }

    public void deleteList() {
        first = null;
    }

    public int length() {
        int ret;
        if (first != null) {
            SLLNode<E> tmp = first;
            ret = 1;
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret++;
            }
            return ret;
        } else
            return 0;

    }

    @Override
    public String toString() {
        String ret = new String();
        if (first != null) {
            SLLNode<E> tmp = first;
            ret += tmp + "->";
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret += tmp + "->";
            }
        } else
            ret = "Prazna lista!!!";
        return ret;
    }

    public void insertFirst(E o) {
        SLLNode<E> ins = new SLLNode<E>(o, first);
        first = ins;
    }

    public void insertAfter(E o, SLLNode<E> node) {
        if (node != null) {
            SLLNode<E> ins = new SLLNode<E>(o, node.succ);
            node.succ = ins;
        } else {
            System.out.println("Dadenot jazol e null");
        }
    }

    public void insertBefore(E o, SLLNode<E> before) {

        if (first != null) {
            SLLNode<E> tmp = first;
            if(first==before){
                this.insertFirst(o);
                return;
            }
            //ako first!=before
            while (tmp.succ != before)
                tmp = tmp.succ;
            if (tmp.succ == before) {
                SLLNode<E> ins = new SLLNode<E>(o, before);
                tmp.succ = ins;
            } else {
                System.out.println("Elementot ne postoi vo listata");
            }
        } else {
            System.out.println("Listata e prazna");
        }
    }

    public void insertLast(E o) {
        if (first != null) {
            SLLNode<E> tmp = first;
            while (tmp.succ != null)
                tmp = tmp.succ;
            SLLNode<E> ins = new SLLNode<E>(o, null);
            tmp.succ = ins;
        } else {
            insertFirst(o);
        }
    }

    public E deleteFirst() {
        if (first != null) {
            SLLNode<E> tmp = first;
            first = first.succ;
            return tmp.element;
        } else {
            System.out.println("Listata e prazna");
            return null;
        }
    }

    public E delete(SLLNode<E> node) {
        if (first != null) {
            SLLNode<E> tmp = first;
            if(first ==node){
                return this.deleteFirst();
            }
            while (tmp.succ != node && tmp.succ.succ != null)
                tmp = tmp.succ;
            if (tmp.succ == node) {
                tmp.succ = tmp.succ.succ;
                return node.element;
            } else {
                System.out.println("Elementot ne postoi vo listata");
                return null;
            }
        } else {
            System.out.println("Listata e prazna");
            return null;
        }

    }

    public SLLNode<E> getFirst() {
        return first;
    }

    public SLLNode<E> find(E o) {
        if (first != null) {
            SLLNode<E> tmp = first;
            while (tmp.element != o && tmp.succ != null)
                tmp = tmp.succ;
            if (tmp.element == o) {
                return tmp;
            } else {
                System.out.println("Elementot ne postoi vo listata");
            }
        } else {
            System.out.println("Listata e prazna");
        }
        return first;
    }

    public Iterator<E> iterator () {
        // Return an iterator that visits all elements of this list, in left-to-right order.
        return new LRIterator<E>();
    }

    // //////////Inner class ////////////

    private class LRIterator<E> implements Iterator<E> {

        private SLLNode<E> place, curr;

        private LRIterator() {
            place = (SLLNode<E>) first;
            curr = null;
        }

        public boolean hasNext() {
            return (place != null);
        }

        public E next() {
            if (place == null)
                throw new NoSuchElementException();
            E nextElem = place.element;
            curr = place;
            place = place.succ;
            return nextElem;
        }

        public void remove() {
            //Not implemented
        }
    }
    public void print()
    {
        SLLNode<E> temp =null;
        for(temp = first ; temp != null ; temp=temp.succ)
        {
            System.out.print(temp.element+" ");
        }

    }

    public void mirror(){
        if (first != null) {
            //m=nextsucc, p=tmp,q=next
            SLLNode<E> tmp = first;
            SLLNode<E> newsucc = null;
            SLLNode<E> next;

            while(tmp != null){
                next = tmp.succ;
                tmp.succ = newsucc;
                newsucc = tmp;
                tmp = next;
            }
            first = newsucc;
        }

    }
    public void removeduplicate()
    {
        SLLNode<E> temp = first;
        while(temp.succ!=null)
        {
            if(temp.element == temp.succ.element)
            {
                temp.succ = temp.succ.succ;
            }
            else
            {
                temp = temp.succ;
            }
        }



    }

    public void merge (SLL<E> in){
        if (first != null) {
            SLLNode<E> tmp = first;
            while(tmp.succ != null)
                tmp = tmp.succ;
            tmp.succ = in.getFirst();
        }
        else{
            first = in.getFirst();
        }
    }
}


public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader((new InputStreamReader(System.in)));
        //int n = Integer.parseInt(br.readLine());
        SLL<Integer> list1 = new SLL<>();
        SLL<Integer> list2 = new SLL<>();
        list1.insertLast(5);
        list1.insertLast(2);
        list1.insertLast(3);
        list2.insertLast(5);
        list2.insertLast(6);
        list2.insertLast(6);
        System.out.println();
        //list1.print();
        SLLNode<Integer> temp1 = list1.getFirst();
        SLLNode<Integer> temp2 = list2.getFirst();
        int n;
        int nr1 = list1.length();
        int nr2 = list2.length();
        if (nr1< nr2)
            n=nr1;
        else
            n=nr2;
        SLL<Integer> new_list = new SLL<>();
        for(int i = 0 ; i < n; i++)
        {
            if(i%2==0)
            {
                new_list.insertLast(temp1.element);
                if(temp1.succ!=null)
                {
                    temp1=temp1.succ;
                }
                else
                {
                    break;
                }
                new_list.insertLast(temp1.element);
                if(temp1.succ!=null)
                {
                    temp1=temp1.succ;
                }
                else
                {
                    break;

                }
            }
            else if   (i%2!=0)
            {

                new_list.insertLast(temp2.element);
                if(temp2.succ!=null)
                    temp2=temp2.succ;
                else
                    break;
                new_list.insertLast(temp2.element);
                if(temp2.succ!=null)
                    temp2=temp2.succ;
                else
                    break;
            }
        }
        while(temp2!=null)
        {
            new_list.insertLast(temp2.element);
            temp2=temp2.succ;
        }
        while(temp1!=null)
        {
            new_list.insertLast(temp1.element);
            temp1=temp1.succ;
        }
        new_list.print();


    }
}
=========================================================================================================
RANGE
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.util.stream.IntStream;
import java.util.stream.LongStream;

public class Range {

    static long binarySearch(long arr[], long l, long r, long x)
    {
        if (r >= l) {
            long mid =  (l + (r - l) / 2);

            // If the element is present at the
            // middle itself
            if (((arr[(int) mid])*(arr[(int) mid]) + s(arr[(int) mid]) + 200*arr[(int) mid]) == x)
                return mid;

            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (((arr[(int) mid])*(arr[(int) mid]) + s(arr[(int) mid]) + 200*arr[(int) mid]) > x)
                return binarySearch(arr, l, mid - 1, x);

            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, r, x);
        }

        // We reach here when element is not present
        // in array
        return -1;
    }

    static long proveri(long N, long A, long B) {
        // Vasiot kod tuka
        long num = -1;
        long[] anArray = LongStream.rangeClosed(A, B).toArray();
        Arrays.sort(anArray);

        num = binarySearch(anArray, A, B, N);


        return num;
    }
    static int s(long n)
    {
        String ss = String.valueOf(n);
        char[]cc = ss.toCharArray();
        int sum = 0;
        for(char c:cc)
        {
            sum+= Character.getNumericValue(c);
        }
        return sum;

    }

    public static void main(String[] args) throws Exception {
        int i,j,k;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        long N = Long.parseLong(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        long A = Long.parseLong(st.nextToken());
        long B = Long.parseLong(st.nextToken());

        long res = proveri(N, A, B);
        System.out.println(res);

        br.close();


    }

}
==========================================================================================================
PHARMACY
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.Iterator;

class MapEntry<K extends Comparable<K>,E> implements Comparable<K> {

    K key;
    E value;

    public MapEntry (K key, E val) {
        this.key = key;
        this.value = val;
    }

    public int compareTo (K that) {
        @SuppressWarnings("unchecked")
        MapEntry<K,E> other = (MapEntry<K,E>) that;
        return this.key.compareTo(other.key);
    }

    public String toString () {
        return  key + " " + value;
    }
}

class SLLNode<E> {
    protected E element;
    protected SLLNode<E> succ;

    public SLLNode(E elem, SLLNode<E> succ) {
        this.element = elem;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}

class CBHT<K extends Comparable<K>, E> {

    private SLLNode<MapEntry<K,E>>[] buckets;

    @SuppressWarnings("unchecked")
    public CBHT(int m) {
        buckets = (SLLNode<MapEntry<K,E>>[]) new SLLNode[m];
    }

    private int hash(K key) {
        return Math.abs(key.hashCode()) % buckets.length;
    }

    public SLLNode<MapEntry<K,E>> search(K targetKey) {
        int b = hash(targetKey);
        for (SLLNode<MapEntry<K,E>> curr = buckets[b]; curr != null; curr = curr.succ) {
            if (targetKey.equals(((MapEntry<K, E>) curr.element).key))
                return curr;
        }
        return null;
    }
    public SLLNode<MapEntry<K, E>> getElem(int m)
    {
        return buckets[m];
    }


    public void insert(K key, E val) {      // Insert the entry <key, val> into this CBHT.
        MapEntry<K, E> newEntry = new MapEntry<K, E>(key, val);
        int b = hash(key);
        for (SLLNode<MapEntry<K,E>> curr = buckets[b]; curr != null; curr = curr.succ) {
            if (key.equals(((MapEntry<K, E>) curr.element).key)) {
                curr.element = newEntry;
                return;
            }
        }
        buckets[b] = new SLLNode<MapEntry<K,E>>(newEntry, buckets[b]);
    }

    public void delete(K key) {
        int b = hash(key);
        for (SLLNode<MapEntry<K,E>> pred = null, curr = buckets[b]; curr != null; pred = curr, curr = curr.succ) {
            if (key.equals(((MapEntry<K,E>) curr.element).key)) {
                if (pred == null)
                    buckets[b] = curr.succ;
                else
                    pred.succ = curr.succ;
                return;
            }
        }
    }

    public String toString() {
        String temp1 = "";
        for (int i = 0; i < buckets.length; i++) {
            temp1 += i + ":";
            for (SLLNode<MapEntry<K,E>> curr = buckets[i]; curr != null; curr = curr.succ) {
                temp1 += curr.element.toString() + " ";
            }
            temp1 += "\n";
        }
        return temp1;
    }

}
class Medicine {
    String name;
    int available;
    int price;
    int amount;
    String shortname;




    public Medicine(String name, int available, int price, int amount) {
        this.name = name.toUpperCase();
        this.available = available;
        this.price = price;
        this.amount = amount;
        shortname = name.substring(0,3).toUpperCase();
    }
    public String checkName(String s)
    {
        if(shortname.equals(s))
            return name;
        return null;
    }
    public void changeAmount(int n)
    {
        if(n>amount)
        {
            System.out.println("Cannot be made");
        }
        amount-=n;
    }
    @Override
    public int hashCode() {

        String name1 = shortname;
        int char1 = name1.charAt(0);
        int char2 = name1.charAt(1);
        int char3 = name1.charAt(2);

        return (29*(29*(char1)+ char2)+ char3) % 102780;
    }

    @Override
    public boolean equals(Object obj) {
        //return super.equals(obj);
        Medicine mm = (Medicine) obj;
        return (this.amount==mm.amount && this.name.equals(mm.name) && this.price==mm.price && this.available ==  mm.available);
    }



   /* @Override
    public int compareTo(Medicine o) {
        //return name.compareTo(o.name) && price > o.price && amount > o.amount &&
        return 0;
    }*/
}
public class Main {
    static int prime(int m)
    {
        BigInteger bi = new BigInteger(String.valueOf(m));
        return  Integer.parseInt(String.valueOf(bi.nextProbablePrime()));
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        CBHT<String,Medicine> bucket = new CBHT<>(n*3/2);
        for(int i =0 ;i <n; i++)
        {
            String [] parts = br.readLine().split(" ");
            Medicine medic = new Medicine(parts[0],Integer.parseInt(parts[1]),Integer.parseInt(parts[2]),Integer.parseInt(parts[3]));
            bucket.insert(parts[0],medic);

        }

        while (true) {
            String s = br.readLine();
            if (s.equals("KRAJ")){
                break;
            }
            String nn = s.toUpperCase();
            if(s.length() == 3){
                SLLNode<MapEntry<String, Medicine>> current = bucket.getElem(0);
                while (current!=null)
                {
                    System.out.println(current.element.value.shortname.equals(nn));
                    current=current.succ;
                }
            }

            SLLNode<MapEntry<String,Medicine>> a = bucket.search(nn);

            if(a==null){
                System.out.println("Nema takov lek");
                String k = br.readLine();
            }
            else {
                System.out.println(a.element.value.name);
                if(a.element.value.available == 1){
                    System.out.println("POS");
                }
                else {
                    System.out.println("NEG");
                }
                System.out.println(a.element.value.price);
                System.out.println(a.element.value.amount);

                String k = br.readLine();
                a.element.value.changeAmount(Integer.parseInt(k));

                if (a.element.value.amount > 0){
                    System.out.println("Napravena naracka");

                }
            }
        }
    }
}
==========================================================================================================
COMPANY 
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;
import java.util.StringJoiner;

class Worker implements Comparable<Worker>
{
    int ID;
    int wage;

    public Worker(int ID, int wage) {
        this.ID = ID;
        this.wage = wage;
    }

    public int getID() {
        return ID;
    }

    public int getWage() {
        return wage;
    }

    @Override
    public int compareTo(Worker o) {
        int i  = 0;
        if(this.getID() >  o.getID())
            i = 1;
        else if(this.getID() <  o.getID())
            i=-1;

        return i;

    }
    @Override
    public String toString()
    {
        StringJoiner sj = new StringJoiner(" ");
        sj.add(String.valueOf(ID));
        sj.add(String.valueOf(wage));
        return sj.toString();
    }
}
class DLLNode<E> {
    protected E element;
    protected DLLNode<E> pred, succ;

    public DLLNode(E elem, DLLNode<E> pred, DLLNode<E> succ) {
        this.element = elem;
        this.pred = pred;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}
class DLL<E> {
    private DLLNode<E> first, last;

    public DLL() {
        // Construct an empty SLL
        this.first = null;
        this.last = null;
    }

    public void deleteList() {
        first = null;
        last = null;
    }

    public int length() {
        int ret;
        if (first != null) {
            DLLNode<E> tmp = first;
            ret = 1;
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret++;
            }
            return ret;
        } else
            return 0;

    }

    public DLLNode<E> find(E o) {
        if (first != null) {
            DLLNode<E> tmp = first;
            while (tmp.element != o && tmp.succ != null)
                tmp = tmp.succ;
            if (tmp.element == o) {
                return tmp;
            } else {
                System.out.println("Elementot ne postoi vo listata");
            }
        } else {
            System.out.println("Listata e prazna");
        }
        return first;
    }

    public void insertFirst(E o) {
        DLLNode<E> ins = new DLLNode<E>(o, null, first);
        if (first == null)
            last = ins;
        else
            first.pred = ins;
        first = ins;
    }

    public void insertLast(E o) {
        if (first == null)
            insertFirst(o);
        else {
            DLLNode<E> ins = new DLLNode<E>(o, last, null);
            last.succ = ins;
            last = ins;
        }
    }

    public void insertAfter(E o, DLLNode<E> after) {
        if(after==last){
            insertLast(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, after, after.succ);
        after.succ.pred = ins;
        after.succ = ins;
    }

    public void insertBefore(E o, DLLNode<E> before) {
        if(before == first){
            insertFirst(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, before.pred, before);
        before.pred.succ = ins;
        before.pred = ins;
    }

    public E deleteFirst() {
        if (first != null) {
            DLLNode<E> tmp = first;
            first = first.succ;
            if (first != null) first.pred = null;
            if (first == null)
                last = null;
            return tmp.element;
        } else
            return null;
    }

    public E deleteLast() {
        if (first != null) {
            if (first.succ == null)
                return deleteFirst();
            else {
                DLLNode<E> tmp = last;
                last = last.pred;
                last.succ = null;
                return tmp.element;
            }
        }
        // else throw Exception
        return null;
    }

    public E delete(DLLNode<E> node) {
        if(node==first){
            deleteFirst();
            return node.element;
        }
        if(node==last){
            deleteLast();
            return node.element;
        }
        node.pred.succ = node.succ;
        node.succ.pred = node.pred;
        return node.element;

    }

    @Override
    public String toString() {
        String ret = new String();
        if (first != null) {
            DLLNode<E> tmp = first;
            ret += tmp + "<->";
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret += tmp + "<->";
            }
        } else
            ret = "Prazna lista!!!";
        return ret;
    }

    public String toStringR() {
        String ret = new String();
        if (last != null) {
            DLLNode<E> tmp = last;
            ret += tmp + "<->";
            while (tmp.pred != null) {
                tmp = tmp.pred;
                ret += tmp + "<->";
            }
        } else
            ret = "Prazna lista!!!";
        return ret;
    }

    public DLLNode<E> getFirst() {
        return first;
    }

    public DLLNode<E> getLast() {

        return last;
    }

    public void izvadiDupliIPrebroj(){

    }
}

public class Main {
    public static void sort(DLL<Worker> lista)
    {
        DLLNode<Worker> tmp = lista.getFirst();

        while (tmp !=null){
            DLLNode<Worker> tmp1 = tmp;
            while (tmp1 != null){
                if (tmp.element.ID < tmp1.element.ID){
                    int pom = tmp.element.ID;
                    tmp.element.ID=tmp1.element.ID;
                    tmp1.element.ID=pom;

                    int pom1 = tmp.element.wage;
                    tmp.element.wage=tmp1.element.wage;
                    tmp1.element.wage=pom1;

                }
                tmp1 = tmp1.succ;
            }
            tmp = tmp.succ;
        }
        tmp = lista.getFirst();
        while(tmp!=null)
        {
            System.out.println(tmp);
            tmp = tmp.succ;
        }

    }

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        DLL<Worker> dll = new DLL<>();
        for(int i =0 ; i< n; i++)
        {
            dll.insertLast(new Worker(sc.nextInt(),sc.nextInt()));
        }
        int wag = sc.nextInt();

        DLLNode<Worker> work =  dll.getFirst();
        while(work!=null)
        {
            if(work.element.getWage()< wag)
            {
                dll.delete(work);
            }
            work = work.succ;
        }
        DLLNode<Worker> temp = dll.getFirst();

        //sort(dll);
        DLL<Worker> new_list = new DLL<>();
        int id;
        int wage;
        while (temp != null)
        {
            System.out.println("temp -> " + temp.element);
            DLLNode<Worker> temp1 = temp;
            while(temp1!=null)
            {
                System.out.println("temp1 -> " + temp1.element);
                //System.out.println("temp -> " + temp.element);

                if(temp.element.ID<temp1.element.ID)
                {
                    id = temp1.element.ID;
                    wage = temp1.element.wage;
                    temp1.element.ID = temp.element.ID;
                    temp1.element.wage = temp.element.wage;
                    temp.element.ID = id;
                    temp.element.wage = wage;


                }
                temp1 = temp1.succ;
            }
            temp = temp.succ;
            if(temp!=null) {
                System.out.println("temp -> " + temp.element);
            }


        }
         temp = dll.getFirst();
        if(temp == null)
        {
            System.out.println("nema");
        }
        else {
            while (temp != null) {
                System.out.println(temp.element);
                temp = temp.succ;
            }
        }
        /*while (temp !=  null)
        {
            StringJoiner sj = new StringJoiner(" ");
            sj.add(String.valueOf(temp.element.getID()));
            sj.add(String.valueOf(temp.element.getWage()));
            System.out.println(sj.toString());
            temp=temp.succ;
        }*/



    }
}
==========================================================================================================
PASSWORDS
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

class MapEntry<K extends Comparable<K>,E> implements Comparable<K> {

    K key;
    E value;

    public MapEntry (K key, E val) {
        this.key = key;
        this.value = val;
    }

    public int compareTo (K that) {
        @SuppressWarnings("unchecked")
        MapEntry<K,E> other = (MapEntry<K,E>) that;
        return this.key.compareTo(other.key);
    }

    public String toString () {
        return  key + " " + value;
    }
}

class SLLNode<E> {
    protected E element;
    protected SLLNode<E> succ;

    public SLLNode(E elem, SLLNode<E> succ) {
        this.element = elem;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}

class CBHT<K extends Comparable<K>, E> {

    private SLLNode<MapEntry<K,E>>[] buckets;

    @SuppressWarnings("unchecked")
    public CBHT(int m) {
        buckets = (SLLNode<MapEntry<K,E>>[]) new SLLNode[m];
    }

    private int hash(K key) {
        return Math.abs(key.hashCode()) % buckets.length;
    }

    public SLLNode<MapEntry<K,E>> search(K targetKey) {
        int b = hash(targetKey);
        for (SLLNode<MapEntry<K,E>> curr = buckets[b]; curr != null; curr = curr.succ) {
            if (targetKey.equals(((MapEntry<K, E>) curr.element).key))
                return curr;
        }
        return null;
    }

    public void insert(K key, E val) {      // Insert the entry <key, val> into this CBHT.
        MapEntry<K, E> newEntry = new MapEntry<K, E>(key, val);
        int b = hash(key);
        for (SLLNode<MapEntry<K,E>> curr = buckets[b]; curr != null; curr = curr.succ) {
            if (key.equals(((MapEntry<K, E>) curr.element).key)) {
                curr.element = newEntry;
                return;
            }
        }
        buckets[b] = new SLLNode<MapEntry<K,E>>(newEntry, buckets[b]);
    }

    public void delete(K key) {
        int b = hash(key);
        for (SLLNode<MapEntry<K,E>> pred = null, curr = buckets[b]; curr != null; pred = curr, curr = curr.succ) {
            if (key.equals(((MapEntry<K,E>) curr.element).key)) {
                if (pred == null)
                    buckets[b] = curr.succ;
                else
                    pred.succ = curr.succ;
                return;
            }
        }
    }

    public String toString() {
        String temp1 = "";
        for (int i = 0; i < buckets.length; i++) {
            temp1 += i + ":";
            for (SLLNode<MapEntry<K,E>> curr = buckets[i]; curr != null; curr = curr.succ) {
                temp1 += curr.element.toString() + " ";
            }
            temp1 += "\n";
        }
        return temp1;
    }

}


public class Lozinki {
    static int nextPrime(int m)
    {
        BigInteger b = new BigInteger(String.valueOf(m));
        return Integer.parseInt(b.nextProbablePrime().toString());
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        CBHT<String,String> bucket = new CBHT<>(nextPrime((N*3)/2));
        for(int i = 0; i< N;i++)
        {
            String[] split = br.readLine().split(" ");
            bucket.insert(split[0],split[1]);
        }
        String s;
        while(!(s = br.readLine()).equals("KRAJ"))
        {
            String[] parts = s.split(" ");
            SLLNode<MapEntry<String,String>>temp = bucket.search(parts[0]);
            if(temp==null)
            {
                System.out.println("Nenajaven");
            }
            else
            {
                if(temp.element.value.equals(parts[1]))
                {
                    System.out.println("Najaven");
                }
                else {
                    System.out.println("Nenajaven");
                }
                //String
                //if(temp.element)
            }
            //System.out.println(temp.element);
        }
    }
}
==========================================================================================================
TRANSLATOR
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;

class MapEntry<K extends Comparable<K>,E> implements Comparable<K> {

    K key;
    E value;

    public MapEntry (K key, E val) {
        this.key = key;
        this.value = val;
    }
    public int compareTo (K that) {
        @SuppressWarnings("unchecked")
        MapEntry<K,E> other = (MapEntry<K,E>) that;
        return this.key.compareTo(other.key);
    }
    public String toString () {
        return "(" + key + "," + value + ")";
    }
}


class OBHT<K extends Comparable<K>,E> {

    private MapEntry<K,E>[] buckets;
    static final int NONE = -1; // ... distinct from any bucket index.
    @SuppressWarnings({ "rawtypes", "unchecked" })
    private static final MapEntry former = new MapEntry(null, null);
    private int occupancy = 0;

    @SuppressWarnings("unchecked")
    public OBHT (int m) {
        buckets = (MapEntry<K,E>[]) new MapEntry[m];
    }

    private int hash (K key) {
        return Math.abs(key.hashCode()) % buckets.length;
    }

    public MapEntry<K,E> getBucket(int i){
        return buckets[i];
    }

    public int search (K targetKey) {
        int b = hash(targetKey); int n_search=0;
        for (;;) {
            MapEntry<K,E> oldEntry = buckets[b];
            if (oldEntry == null)
                return NONE;
            else if (targetKey.equals(oldEntry.key))
                return b;
            else{
                b = (b + 1) % buckets.length;
                n_search++;
                if(n_search==buckets.length)
                    return -1;
            }
        }
    }

    public void insert (K key, E val) {
        MapEntry<K,E> newEntry = new MapEntry<K,E>(key, val);
        int b = hash(key); int n_search=0;

        for (;;) {
            MapEntry<K,E> oldEntry = buckets[b];
            if (oldEntry == null) {
                if (++occupancy == buckets.length) {
                    System.out.println("Hash tabelata e polna!!!");
                }
                buckets[b] = newEntry;
                return;
            } else if (oldEntry == former
                    || key.equals(oldEntry.key)) {
                buckets[b] = newEntry;
                return;
            } else{
                b = (b + 1) % buckets.length;
                n_search++;
                if(n_search==buckets.length)
                    return;

            }
        }
    }

    @SuppressWarnings("unchecked")
    public void delete (K key) {
        int b = hash(key); int n_search=0;
        for (;;) {
            MapEntry<K,E> oldEntry = buckets[b];

            if (oldEntry == null)
                return;
            else if (key.equals(oldEntry.key)) {
                buckets[b] = former;
                return;
            } else{
                b = (b + 1) % buckets.length;
                n_search++;
                if(n_search==buckets.length)
                    return;

            }
        }
    }

    public String toString () {
        String temp = "";
        for (int i = 0; i < buckets.length; i++) {
            temp += i + ":";
            if (buckets[i] == null)
                temp += "\n";
            else if (buckets[i] == former)
                temp += "former\n";
            else
                temp += buckets[i] + "\n";
        }
        return temp;
    }
}
class Zbor implements Comparable<Zbor>
{
    String word;

    public Zbor(String word) {
        this.word = word;
    }

    @Override
    public int hashCode() {
        return word.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        //return super.equals(obj);
        Zbor z = (Zbor)obj;
        return word.equals(((Zbor) obj).word);

    }
    @Override
    public String toString()
    {
        return word;
    }
    @Override
    public int compareTo(Zbor o) {
        return word.compareTo(o.word);
    }
}
public class Main {
    static int nextPrime(int n)
    {
        BigInteger bg = new BigInteger(String.valueOf(n));
        return  Integer.parseInt(String.valueOf(bg.nextProbablePrime()));
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        OBHT<Zbor,String>  bucket = new OBHT<>(nextPrime((n*3)/2));
        for(int i=0 ;i < n;i++)
        {
            String[] parts  = br.readLine().split(" ");
            Zbor z = new Zbor(parts[1]);
            bucket.insert(z,parts[0]);
        }
        String s ;
        while(!((s = br.readLine()).equals("KRAJ")))
        {
            Zbor z  = new Zbor(s);
            int i = bucket.search(z);
            if(i == (-1)) {
                System.out.println("/");
            }
            else {
                MapEntry<Zbor, String> temp1 = bucket.getBucket(i);
                System.out.println(temp1.value);

            }

        }
    }

}
=========================================================================================================
List Of Lists
import java.util.Scanner;

class DLLNode<E> {
    protected E element;
    protected DLLNode<E> pred, succ;

    public DLLNode(E elem, DLLNode<E> pred, DLLNode<E> succ) {
        this.element = elem;
        this.pred = pred;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return "<-" + element.toString() + "->";
    }
}

class DLL<E> {
    private DLLNode<E> first, last;

    public DLL() {
        // Construct an empty SLL
        this.first = null;
        this.last = null;
    }

    public void deleteList() {
        first = null;
        last = null;
    }

    public int length() {
        int ret;
        if (first != null) {
            DLLNode<E> tmp = first;
            ret = 1;
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret++;
            }
            return ret;
        } else
            return 0;

    }

    public void insertFirst(E o) {
        DLLNode<E> ins = new DLLNode<E>(o, null, first);
        if (first == null)
            last = ins;
        else
            first.pred = ins;
        first = ins;
    }

    public void insertLast(E o) {
        if (first == null)
            insertFirst(o);
        else {
            DLLNode<E> ins = new DLLNode<E>(o, last, null);
            last.succ = ins;
            last = ins;
        }
    }

    public void insertAfter(E o, DLLNode<E> after) {
        if (after == last) {
            insertLast(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, after, after.succ);
        after.succ.pred = ins;
        after.succ = ins;
    }

    public void insertBefore(E o, DLLNode<E> before) {
        if (before == first) {
            insertFirst(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<E>(o, before.pred, before);
        before.pred.succ = ins;
        before.pred = ins;
    }

    public E deleteFirst() {
        if (first != null) {
            DLLNode<E> tmp = first;
            first = first.succ;
            if (first != null) first.pred = null;
            if (first == null)
                last = null;
            return tmp.element;
        } else
            return null;
    }

    public E deleteLast() {
        if (first != null) {
            if (first.succ == null)
                return deleteFirst();
            else {
                DLLNode<E> tmp = last;
                last = last.pred;
                last.succ = null;
                return tmp.element;
            }
        }
        // else throw Exception
        return null;
    }

    @Override
    public String toString() {
        String ret = new String();
        if (first != null) {
            DLLNode<E> tmp = first;
            ret += tmp + "<->";
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret += tmp + "<->";
            }
        } else
            ret = "Prazna lista!!!";
        return ret;
    }

    public DLLNode<E> getFirst() {
        return first;
    }

    public DLLNode<E> getLast() {

        return last;
    }

}

public class ListaOdListi {

    public static long findMagicNumber(DLL<DLL<Integer>> list) {
        //Vashiot kod tuka...
        long multsum = 1;
        DLLNode<DLL<Integer>> list1 = list.getFirst();
        while(list1!=null) {
            DLLNode<Integer> temp = list1.element.getFirst();

            int sum = 0;
            while (temp != null)
            {
                sum += temp.element;
                temp = temp.succ;
            }
            multsum = multsum * sum;
            list1 = list1.succ;
        }



        return multsum;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        DLL<DLL<Integer>> list = new DLL<DLL<Integer>>();
        for (int i = 0; i < n; i++) {
            DLL<Integer> tmp = new DLL<Integer>();
            for (int j = 0; j < m; j++) {
                tmp.insertLast(in.nextInt());
            }
            list.insertLast(tmp);
        }
        in.close();
        System.out.println(findMagicNumber(list));
    }

}
==========================================================================================================
WINDOWS EXPLORER
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringJoiner;
import java.util.StringTokenizer;
import java.util.Iterator;
import java.util.NoSuchElementException;

interface Tree<E> {
    ////////////Accessors ////////////

    public Node<E> root();

    public Node<E> parent(Node<E> node);

    public int childCount(Node<E> node);

    ////////////Transformers ////////////
    public void makeRoot(E elem);

    public Node<E> addChild(Node<E> node, E elem);

    public void remove(Node<E> node);

    ////////////Iterator ////////////
    public Iterator<E> children(Node<E> node);

}

interface Node<E> {

    public E getElement();

    public void setElement(E elem);
}


class SLLTree<E> implements Tree<E> {

    public SLLNode<E> root;

    public SLLTree() {
        root = null;
    }

    public Node<E> root() {
        return root;
    }

    public Node<E> parent(Node<E> node) {
        return ((SLLNode<E>) node).parent;
    }

    public int childCount(Node<E> node) {
        SLLNode<E> tmp = ((SLLNode<E>) node).firstChild;
        int num = 0;
        while (tmp != null) {
            tmp = tmp.sibling;
            num++;
        }
        return num;
    }

    public void makeRoot(E elem) {
        root = new SLLNode<E>(elem);
    }

    public Node<E> addChild(Node<E> node, E elem) {
        SLLNode<E> tmp = new SLLNode<E>(elem);
        SLLNode<E> curr = (SLLNode<E>) node;
        tmp.sibling = curr.firstChild;
        curr.firstChild = tmp;
        tmp.parent = curr;
        return tmp;
    }

    public void remove(Node<E> node) {
        SLLNode<E> curr = (SLLNode<E>) node;
        if (curr.parent != null) {
            if (curr.parent.firstChild == curr) {
                // The node is the first child of its parent
                // Reconnect the parent to the next sibling
                curr.parent.firstChild = curr.sibling;
            } else {
                // The node is not the first child of its parent
                // Start from the first and search the node in the sibling list and remove it
                SLLNode<E> tmp = curr.parent.firstChild;
                while (tmp.sibling != curr) {
                    tmp = tmp.sibling;
                }
                tmp.sibling = curr.sibling;
            }
        } else {
            root = null;
        }
    }

    class SLLTreeIterator<T> implements Iterator<T> {

        SLLNode<T> start, current;

        public SLLTreeIterator(SLLNode<T> node) {
            start = node;
            current = node;
        }

        public boolean hasNext() {
            return (current != null);
        }

        public T next() throws NoSuchElementException {
            if (current != null) {
                SLLNode<T> tmp = current;
                current = current.sibling;
                return tmp.getElement();
            } else {
                throw new NoSuchElementException();
            }
        }

        public void remove() {
            if (current != null) {
                current = current.sibling;
            }
        }
    }

    public Iterator<E> children(Node<E> node) {
        return new SLLTreeIterator<E>(((SLLNode<E>) node).firstChild);
    }

    void printTreeRecursive(Node<E> node, int level) {
        if (node == null)
            return;
        int i;
        SLLNode<E> tmp;

        for (i=0;i<level;i++)
            System.out.print(" ");
        System.out.println(node.getElement().toString());
        tmp = ((SLLNode<E>)node).firstChild;
        while (tmp != null) {
            printTreeRecursive(tmp, level+1);
            tmp = tmp.sibling;
        }
    }

    public void printTree() {
        printTreeRecursive(root, 0);
    }

}

class SLLNode<P> implements Node<P> {

    // Holds the links to the needed nodes
    public SLLNode<P> parent, sibling, firstChild;
    // Hold the data
    public P element;

    public SLLNode(P o) {
        element = o;
        parent = sibling = firstChild = null;
    }

    public P getElement() {
        return element;
    }

    public void setElement(P o) {
        element = o;
    }
}

public class WindowsExplorer {

    public static void main(String[] args) throws Exception {
        int i,j,k;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        String commands[] = new String[N];

        for (i=0;i<N;i++)
            commands[i] = br.readLine();

        br.close();

        SLLTree<String> tree = new SLLTree<String>();
        tree.makeRoot("c:");
        SLLNode<String> current = tree.root;
        // vasiot kod stoi ovde
        for(j =0 ; j<commands.length;j++)
        {
            String[] parts = commands[j].split(" ");
            String command = parts[0];
            String node = null;
            if(parts.length==2)
            {
                node = parts[1];
            }

            if(command.equals("CREATE"))
            {
                SLLNode<String> temp = current.firstChild;
                if(temp == null || temp.element.compareTo(node)>0)
                {
                    tree.addChild(current, node);
                }
                else {
                    SLLNode<String> ins = new SLLNode<>(node);
                    while(temp.sibling!=null)
                    {
                        if(ins.element.compareTo(temp.element)>0)
                        {
                            ins.sibling=temp.sibling;
                            temp.sibling=ins;
                            ins.parent=current;
                            break;
                        }
                        temp=temp.sibling;
                    }
                    ins.parent=current;
                    temp.sibling=ins;
                }

            }
            else if (command.equals("OPEN"))
            {
                SLLNode<String> open = current.firstChild;
                while(open!=null)
                {
                    if(open.element.equals(node))
                    {
                        current = open;
                    }
                    open = open.sibling;
                }

            }
            else if (command.equals("PATH"))
            {
                SLLNode<String> temp = current;
                StringBuilder sj = new StringBuilder();
                while(temp!=tree.root)
                {
                    sj.insert(0,"\\").insert(0,temp.element);
                    temp=temp.parent;
                }

                sj.insert(0,"\\").insert(0,tree.root.element);
                System.out.println(sj.toString());
            }
            else if(command.equals("BACK"))
            {
                current=current.parent;
            }
            else if(command.equals("PRINT"))
            {
                    tree.printTree();
            }
            else if(command.equals("DELETE"))
            {
                SLLNode<String> del = new SLLNode<>(node);
                SLLNode<String> temp = current.firstChild;
                if(temp!=null && temp.element.equals(del.element))
                {
                    current.firstChild = temp.firstChild.sibling;
                }
                while (temp!=null)
                {
                    if(temp.sibling.element.equals(del.element))
                    {
                        temp.sibling= temp.sibling.sibling;
                        break;
                    }
                    temp = temp.sibling;
                }
            }


        }


    }

}
==========================================================================================================
PREORDER NON RECURSIVE
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

class BNode<E> {

    public E info;
    public BNode<E> left;
    public BNode<E> right;

    static int LEFT = 1;
    static int RIGHT = 2;

    public BNode(E info) {
        this.info = info;
        left = null;
        right = null;
    }

    public BNode() {
        this.info = null;
        left = null;
        right = null;
    }

    public BNode(E info, BNode<E> left, BNode<E> right) {
        this.info = info;
        this.left = left;
        this.right = right;
    }

}

class BTree<E> {

    public BNode<E> root;

    public BTree() {
        root = null;
    }

    public BTree(E info) {
        root = new BNode<E>(info);
    }

    public void makeRoot(E elem) {
        root = new BNode(elem);
    }

    public void makeRootNode(BNode<E> node) {
        root = node;
    }

    public BNode<E> addChild(BNode<E> node, int where, E elem) {

        BNode<E> tmp = new BNode<E>(elem);

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }

        return tmp;
    }

    public BNode<E> addChildNode(BNode<E> node, int where, BNode<E> tmp) {

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }

        return tmp;
    }

    public void PreorderNonRecursive() {
        // vasiot kod ovde
        Deque<BNode> deque = new ArrayDeque<>();
        deque.push(root);
        StringJoiner sj = new StringJoiner(" ");
        while(!deque.isEmpty())
        {
            BNode<E> elem = deque.pop();
            sj.add(String.valueOf(elem.info));
            if(elem.right!=null)
                deque.push(elem.right);
            if(elem.left!=null)
                deque.push(elem.left);


        }
        System.out.println(sj.toString());
    }

}

interface Stack<E> {

    // Elementi na stekot se objekti od proizvolen tip.

    // Metodi za pristap:

    public boolean isEmpty ();
    // Vrakja true ako i samo ako stekot e prazen.

    public E peek ();
    // Go vrakja elementot na vrvot od stekot.

    // Metodi za transformacija:

    public void clear ();
    // Go prazni stekot.

    public void push (E x);
    // Go dodava x na vrvot na stekot.

    public E pop ();
    // Go otstranuva i vrakja elementot shto e na vrvot na stekot.
}

class ArrayStack<E> implements Stack<E> {
    private E[] elems;
    private int depth;

    @SuppressWarnings("unchecked")
    public ArrayStack (int maxDepth) {
        // Konstrukcija na nov, prazen stek.
        elems = (E[]) new Object[maxDepth];
        depth = 0;
    }


    public boolean isEmpty () {
        // Vrakja true ako i samo ako stekot e prazen.
        return (depth == 0);
    }


    public E peek () {
        // Go vrakja elementot na vrvot od stekot.
        if (depth == 0)
            throw new NoSuchElementException();
        return elems[depth-1];
    }


    public void clear () {
        // Go prazni stekot.
        for (int i = 0; i < depth; i++)  elems[i] = null;
        depth = 0;
    }


    public void push (E x) {
        // Go dodava x na vrvot na stekot.
        elems[depth++] = x;
    }


    public E pop () {
        // Go otstranuva i vrakja elementot shto e na vrvot na stekot.
        if (depth == 0)
            throw new NoSuchElementException();
        E topmost = elems[--depth];
        elems[depth] = null;
        return topmost;
    }
}

public class PreorderNonRecursive {

    public static void main(String[] args) throws Exception {
        int i, j, k;
        int index;
        String action;

        String line;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int N = Integer.parseInt(br.readLine());

        BNode<String> nodes[] = new BNode[N];
        BTree<String> tree = new BTree<String>();

        for (i=0;i<N;i++)
            nodes[i] = new BNode<String>();

        for (i = 0; i < N; i++) {
            line = br.readLine();
            st = new StringTokenizer(line);
            index = Integer.parseInt(st.nextToken());
            nodes[index].info = st.nextToken();
            action = st.nextToken();
            if (action.equals("LEFT")) {
                tree.addChildNode(nodes[Integer.parseInt(st.nextToken())], BNode.LEFT, nodes[index]);
            } else if (action.equals("RIGHT")) {
                tree.addChildNode(nodes[Integer.parseInt(st.nextToken())], BNode.RIGHT, nodes[index]);
            } else {
                // this node is the root
                tree.makeRootNode(nodes[index]);
            }
        }

        br.close();

        tree.PreorderNonRecursive();

    }
}
=========================================================================================
SUM OF ELEMENTS BINARY TREE
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.StringTokenizer;

class BNode<E> {

    public E info;
    public BNode<E> left;
    public BNode<E> right;

    static int LEFT = 1;
    static int RIGHT = 2;

    public BNode(E info) {
        this.info = info;
        left = null;
        right = null;
    }

    public BNode() {
        this.info = null;
        left = null;
        right = null;
    }

    public BNode(E info, BNode<E> left, BNode<E> right) {
        this.info = info;
        this.left = left;
        this.right = right;
    }

}

class BTree<E extends Comparable<E>> {

    public BNode<E> root;

    public BTree() {
        root = null;
    }

    public BTree(E info) {
        root = new BNode<E>(info);
    }

    public void makeRoot(E elem) {
        root = new BNode(elem);
    }

    public void makeRootNode(BNode<E> node) {
        root = node;
    }

    public BNode<E> addChild(BNode<E> node, int where, E elem) {

        BNode<E> tmp = new BNode<E>(elem);

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }

        return tmp;
    }

    public BNode<E> addChildNode(BNode<E> node, int where, BNode<E> tmp) {

        if (where == BNode.LEFT) {
            if (node.left != null)  // veke postoi element
                return null;
            node.left = tmp;
        } else {
            if (node.right != null) // veke postoi element
                return null;
            node.right = tmp;
        }

        return tmp;
    }
    private BNode<E> find(E x, BNode<E> t) {
        if (t == null)
            return null;

        if (x.compareTo(t.info) < 0) {
            return find(x, t.left);
        } else if (x.compareTo(t.info) > 0) {
            return find(x, t.right);
        } else {
            return t;    // Match
        }
    }
    public BNode<E> find(E x) {
        return find(x, root);
    }
    public void findSum(BNode<Integer> t) {
        int sum1 = 0;
        int sum2 = 0;
        Deque<BNode<Integer>> dq1 = new ArrayDeque<>();
        Deque<BNode<Integer>> dq2 = new ArrayDeque<>();
        dq1.push(t.left);
        dq2.push(t.right);
        while(!dq1.isEmpty())
        {
            BNode<Integer> temp = dq1.pop();
            if(temp.info < t.info)
            {
                sum1 += Integer.valueOf(temp.info);
            }
            if(temp.right!=null)
                dq1.push(temp.right);

            if(temp.left!=null)
                dq1.push(temp.left);

        }
        while(!dq2.isEmpty())
        {
            BNode<Integer> temp = dq2.pop();
            if(temp.info > t.info)
            {
                sum2 += Integer.valueOf(temp.info);
            }
            if(temp.right!=null)
                dq2.push(temp.right);

            if(temp.left!=null)
                dq2.push(temp.left);
        }

        System.out.println(sum1 + " " + sum2);
    }

}

public class BinaryTreeSum {


    public static void main(String[] args) throws Exception {
        int i, j, k;
        int index;
        String action;

        String line;

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int N = Integer.parseInt(br.readLine());

        BNode<Integer> nodes[] = new BNode[N];
        BTree<Integer> tree = new BTree<Integer>();

        for (i=0;i<N;i++)
            nodes[i] = new BNode<Integer>();

        for (i = 0; i < N; i++) {
            line = br.readLine();
            st = new StringTokenizer(line);
            index = Integer.parseInt(st.nextToken());
            nodes[index].info = Integer.parseInt(st.nextToken());
            action = st.nextToken();
            if (action.equals("LEFT")) {
                tree.addChildNode(nodes[Integer.parseInt(st.nextToken())], BNode.LEFT, nodes[index]);
            } else if (action.equals("RIGHT")) {
                tree.addChildNode(nodes[Integer.parseInt(st.nextToken())], BNode.RIGHT, nodes[index]);
            } else {
                // this node is the root
                tree.makeRootNode(nodes[index]);
            }
        }

        int baranaVrednost=Integer.parseInt(br.readLine());
        BNode<Integer> found = tree.find(baranaVrednost);
        tree.findSum(found);

        br.close();

        // vasiot kod ovde

    }
}

